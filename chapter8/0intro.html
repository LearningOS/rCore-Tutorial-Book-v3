

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>引言 &mdash; rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/my_style.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script kind="utterances">

    var commentsRunWhenDOMLoaded = cb => {
    if (document.readyState != 'loading') {
        cb()
    } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', cb)
    } else {
        document.attachEvent('onreadystatechange', function() {
        if (document.readyState == 'complete') cb()
        })
    }
}

var addUtterances = () => {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "https://utteranc.es/client.js";
    script.async = "async";

    script.setAttribute("repo", "rcore-os/rCore-Tutorial-Book-v3");
    script.setAttribute("issue-term", "pathname");
    script.setAttribute("theme", "github-light");
    script.setAttribute("label", "comments");
    script.setAttribute("crossorigin", "anonymous");

    sections = document.querySelectorAll("div.section");
    if (sections !== null) {
        section = sections[sections.length-1];
        section.appendChild(script);
    }
}
commentsRunWhenDOMLoaded(addUtterances);
</script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="用户态的线程管理" href="1thread.html" />
    <link rel="prev" title="第八章：并发" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> rCore-Tutorial-Book-v3
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Part1 - Just do it!</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../chapter0/index.html">第零章：操作系统概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter1/index.html">第一章：应用程序与基本执行环境</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter2/index.html">第二章：批处理系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter3/index.html">第三章：多道程序与分时多任务</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter4/index.html">第四章：地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter5/index.html">第五章：进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter6/index.html">第六章：文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter7/index.html">第七章：进程间通信与 I/O 重定向</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第八章：并发</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">引言</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">本章导读</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#term-thread-define">线程定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">同步互斥</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">实践体验</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">本章代码树</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">本章代码导读</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="1thread.html">用户态的线程管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="1thread-kernel.html">内核态的线程管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="2lock.html">锁机制</a></li>
<li class="toctree-l2"><a class="reference internal" href="3semaphore.html">信号量机制</a></li>
<li class="toctree-l2"><a class="reference internal" href="4condition-variable.html">条件变量机制</a></li>
<li class="toctree-l2"><a class="reference internal" href="5concurrency-problem.html">并发中的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="6exercise.html">练习</a></li>
<li class="toctree-l2"><a class="reference internal" href="7answer.html">练习参考答案</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter9/index.html">第九章：I/O设备管理</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">附录</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../final-lab.html">综合练习</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-a/index.html">附录 A：Rust 系统编程入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-b/index.html">附录 B：常见工具的使用方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-c/index.html">附录 C：深入机器模式：RustSBI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-d/index.html">附录 D：RISC-V相关信息</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-e/index.html">附录 E：操作系统进一步介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../terminology.html">术语中英文对照表</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">开发注记</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../setup-sphinx.html">修改和构建本项目</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rest-example.html">reStructuredText 基本语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../log.html">更新日志</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">rCore-Tutorial-Book-v3</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">第八章：并发</a> &raquo;</li>
        
      <li>引言</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/chapter8/0intro.rst.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>引言<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>本章导读<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>到本章开始之前，我们好像已经完成了组成应用程序执行环境的操作系统的三个重要抽象：进程、地址空间和文件，让应用程序开发、运行和存储数据越来越方便和灵活。特别是操作系统支持分时多任务和抢占式调度，通过硬件中断机制，能强制打断进程的执行，及时处理I/O交互操作，从而提高整个系统的执行效率。有了进程以后，可以让操作系统从宏观层面实现多个应用的并发执行，而并发是通过操作系统基于处理器的时间片不断地切换进程来达到的。对于单核处理器而言，在任意一个时刻只会有一个进程被操作系统调度，在被处理器上执行。到目前为止的并发，仅仅是进程间的并发，而对于一个进程内部，还没有并发性的体现。而这就是线程（Thread）出现的起因：提高一个进程内的并发性。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>解决并发问题的THE操作系统</p>
<p>早期的计算机硬件没有内存隔离保护机制，多个程序以任务（task）的形式进行执行，但各个任务之间是依次执行（批处理方式）或相互独立执行，基本没有数据共享的情况，所以还没有形成线程的概念。当多个任务需要共享数据和同步行为时，就需要扩展任务的这些新的执行特征，并建立相应的同步互斥机制。在1962年，荷兰的E.W.Dijkstra 教授和他的团队正在为 Electrologica X8 计算机开发 THE 操作系统。他们观察到如果多个程序在执行中访问共享变量，在E.W.Dijkstra 教授在信号量机制的研究中，提出了多个“sequential processes”可以通过信号量机制合作访问共享变量，避免冲突导致结果不确定。这里的“sequential processes”的含义就是线程。</p>
<p>1964年开始设计的Multics操作系统已经有进程的概念，也有多处理器并行处理的GE 645硬件设计，甚至提出了线程的概念。1966年，参与Multics开发的MIT博士生 Jerome Howard Saltzer在其博士毕业论文的一个注脚提到贝尔实验室的Victor A. Vyssotsky用“thead”这个名称来表示处理器（processor）执行程序（program）代码序列这个过程的抽象概念，Saltzer进一步把”进程（process）”描述为处理器执行程序代码的当前状态（即线程）和可访问的地址空间。但他们并没有建立类似信号量这样的有效机制来避免并发带来的同步互斥问题。</p>
<p>Dijkstra 教授带领他的小团队在设计开发THE操作系统的过程中，异步中断触发的难以重现的并发错误，让他们在调试操作系统中碰到了困难。这种困难激发了Dijkstra的灵感，他们除了设计了操作系统的分层结构之外，还设计了信号量机制和对应的P和V操作，来确保线程对共享变量的灵活互斥访问，并支持线程之间的同步操作。P和V是来自荷兰语单词“测试”和“增加”的首字母，是很罕见的非英语来源的操作系统术语。</p>
<p>丹麦的Brinch Hansen，英国的Tony Hoare和Dijkstra并不满足于信号量来解决操作系统和应用中的并发问题。因为对于复杂一些的同步互斥问题（如哲学家问题），如果使用信号量机制不小心，容易引起死锁等错误。在 1971年 的研讨会上，他们三人开始讨论管程（Monitor）的想法，希望设计一种更高级的并发管理语言结构，便于程序员开发并发程序。在1972年春天，Brinch Hansen 在他写的“操作系统原理”教科书中，提出了管程的概念，并把这一概念嵌入到了Concurrent Pascal 编程语言中，然后他和他的学生再接再厉，在PDP 11/45计算机上编写了Concurrent Pascal 编译器，并用Concurrent Pascal 编写了Solo操作系统。Brinch Hansen在操作系统和语言级并发处理方面的开创性工作影响了后续的操作系统并发处理机制（如条件变量等）和不少的编程语言并发方案。</p>
<p>Brinch Hansen的两句名言：</p>
<blockquote>
<div><ul class="simple">
<li><p>写作是对简单性的严格测试：不可能令人信服地写出无法理解的想法。</p></li>
<li><p>编程是用清晰的散文写文章并使它们可执行的艺术</p></li>
</ul>
</div></blockquote>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><strong>并行与并发的区别</strong></p>
<p>可回顾一下 <a class="reference internal" href="../chapter0/4os-features.html#term-parallel-concurrency"><span class="std std-ref">并行与并发的解释</span></a> 。</p>
</div>
<p>有了进程以后，为什么还会出现线程（Thread）呢？考虑如下情况，对于很多应用（以单一进程的形式运行）而言，逻辑上存在多个可并行执行的任务，如果其中一个任务被阻塞，将会引起不依赖该任务的其他任务也被阻塞。举个具体的例子，我们平常用编辑器来编辑文本内容的时候，都会有一个定时自动保存的功能，这个功能的作用是在系统或应用本身出现故障的情况前，已有的文档内容会被提前保存。假设编辑器自动保存时由于磁盘性能导致写入较慢，导致整个进程被操作系统挂起，这就会影响到用户编辑文档的人机交互体验：即软件的及时响应能力不足，用户只有等到磁盘写入完成后，操作系统重新调度该进程运行后，用户才可编辑。如果我们把一个进程内的多个可并行执行任务通过一种更细粒度的方式让操作系统进行调度，那么就可以通过处理器时间片切换实现这种细粒度的并发执行。这种细粒度的调度对象就是线程。</p>
<div class="section" id="term-thread-define">
<span id="id3"></span><h3>线程定义<a class="headerlink" href="#term-thread-define" title="永久链接至标题">¶</a></h3>
<p>简单地说，线程是进程的组成部分，进程可包含1 – n个线程，属于同一个进程的线程共享进程的资源，比如地址空间，打开的文件等。基本的线程由线程ID、执行状态、当前指令指针(PC)、寄存器集合和栈组成。线程是可以被操作系统或用户态调度器独立调度（Scheduling）和分派（Dispatch）的基本单位。</p>
<p>在本章之前，进程是程序的基本执行实体，是程序关于某数据集合上的一次运行活动，是系统进行资源（处理器，地址空间和文件等）分配和调度的基本单位。在有了线程后，对进程的定义也要调整了，进程是线程的资源容器，线程成为了程序的基本执行实体。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<blockquote>
<div><p><strong>线程与进程的区别</strong></p>
<p>下面的比较是以线程为调度对象的操作系统作为分析对象：</p>
<ul class="simple">
<li><p>进程间相互独立（即资源隔离），同一进程的各线程间共享进程的资源（即资源共享）；</p></li>
<li><p>子进程和父进程有不同的地址空间和资源，而多个线程（没有父子关系）则共享同一所属进程的地址空间和资源；</p></li>
<li><p>每个线程有其自己的执行上下文（线程ID、程序计数器、寄存器集合和执行栈），而进程的执行上下文包括其管理的线程执行上下文和地址空间（故同一进程的线程上下文切换比进程上下文切换要快）；</p></li>
<li><p>线程是一个可调度/分派/执行的实体（线程有就绪、阻塞和运行三种基本执行状态），进程不是可调度/分派/执行的的实体，而是线程的资源容器；</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>进程间通信需要通过IPC机制（如管道等）， 属于同一进程的线程间可以共享“即直接读写”进程的数据，但需要同步互斥机制的辅助，以保证数据的一致性。</p></li>
</ul>
</div>
</div>
<div class="section" id="id4">
<h3>同步互斥<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>在上面提到了同步互斥和数据一致性，它们的含义是什么呢？ 当多个线程共享同一进程的地址空间时，每个线程都可以访问属于这个进程的数据（全局变量）。如果每个线程使用到的变量都是其他线程不会读取或者修改的话，那么就不存在一致性问题。如果变量是只读的，多个线程读取该变量也不会有一致性问题。但是，当一个线程修改变量时，其他线程在读取这个变量时，可能会看到一个不一致的值，这就是数据不一致性的问题。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><strong>线程的数据一致性</strong></p>
<p>线程的数据一致性的定义：在单处理器（即只有一个核的CPU）下，如果某线程更新了一个可被其他线程读到的共享数据，那么后续其他线程都能读到这个最新被更新的共享数据。</p>
</div>
<p>为什么会出现线程的数据不一致问题呢？其根本原因是 <strong>调度的不可控性</strong> ：即读写共享变量的代码片段会随时可能被操作系统调度和切换。先看看如下的伪代码例子：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">//全局共享变量 NUM初始化为 0</span>
<span class="linenos"> 2</span><span class="k">static</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">NUM</span><span class="w"> </span>: <span class="kt">usize</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 3</span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="c1">//主进程中的所有线程都会执行如下的核心代码</span>
<span class="linenos"> 6</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">NUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NUM</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 7</span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="c1">//所有线程执行完毕后，主进程显示num的值</span>
<span class="linenos">11</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">12</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;NUM = {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NUM</span><span class="p">);</span><span class="w"></span>
<span class="linenos">13</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果线程的个数为 <code class="docutils literal notranslate"><span class="pre">n</span></code> ，那么最后主进程会显示的数应该是多少呢？ 也许同学觉得应该也是 <code class="docutils literal notranslate"><span class="pre">n</span></code> ，但现实并不是这样。为了了解事实真相，我们首先必须了解Rust编译器对 <a href="#id5"><span class="problematic" id="id6">``</span></a>num = num + 1; `` 这一行源代码生成的汇编代码序列。</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1"># 假设NUM的地址为 0x1000</span>
<span class="linenos">2</span><span class="c1"># unsafe { NUM = NUM + 1; } 对应的汇编代码如下</span>
<span class="linenos">3</span><span class="nf">addi</span> <span class="no">x6</span><span class="p">,</span> <span class="no">x0</span><span class="p">,</span> <span class="mi">0x1000</span>        <span class="c1"># addr 100: 计算NUM的地址</span>
<span class="linenos">4</span>                           <span class="c1"># 由于时钟中断可能会发生线程切换</span>
<span class="linenos">5</span><span class="nf">ld</span>   <span class="no">x5</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">x6</span><span class="p">)</span>             <span class="c1"># addr 104: 把NUM的值加载到x5寄存器中</span>
<span class="linenos">6</span>                           <span class="c1"># 由于时钟中断可能会发生线程切换</span>
<span class="linenos">7</span><span class="nf">addi</span> <span class="no">x5</span><span class="p">,</span> <span class="no">x5</span><span class="p">,</span> <span class="mi">1</span>             <span class="c1"># addr 108: x5 &lt;- x5 + 1</span>
<span class="linenos">8</span>                           <span class="c1"># 由于时钟中断可能会发生线程切换</span>
<span class="linenos">9</span><span class="nf">sd</span>   <span class="no">x5</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">x6</span><span class="p">)</span>             <span class="c1"># addr 112: 把NUM+1的值写回到NUM地址中</span>
</pre></div>
</div>
<p>在这个例子中，一行Rust源代码其实被Rust编译器生成了四行RISC-V汇编代码。如果多个线程在操作系统的管理和调度下都执行这段代码，那么在上述四行汇编代码之间（即第4，6，8行的地方）的时刻可能产生时钟中断，并导致线程调度和切换。</p>
<p>设有两个线程，线程A先进入上述汇编代码区，将要把 <code class="docutils literal notranslate"><span class="pre">NUM</span></code> 增加一，为此线程A将 <code class="docutils literal notranslate"><span class="pre">NUM</span></code> 的值（假设它这时是 <code class="docutils literal notranslate"><span class="pre">0</span></code> ）加载到 <code class="docutils literal notranslate"><span class="pre">x5</span></code> 寄存器中，然后执行加一操作，此时 <code class="docutils literal notranslate"><span class="pre">x5</span> <span class="pre">=</span> <span class="pre">1</span></code> 。这时时钟中断发生，操作系统将当前正在运行的线程A的上下文（（它的程序计数器、寄存器，包括 <code class="docutils literal notranslate"><span class="pre">x5</span></code> 等））保存到线程控制块（在内存中）中。</p>
<p>再接下来，线程B被选中运行，并进入同一段代码。它也执行了前两条条指令，获取NUM的值（此时仍为 <code class="docutils literal notranslate"><span class="pre">0</span></code> ）并将其放入 <code class="docutils literal notranslate"><span class="pre">x5</span></code> 中，线程B继续执行接下来指令，将 <code class="docutils literal notranslate"><span class="pre">x5</span></code> 加一，然后将 <code class="docutils literal notranslate"><span class="pre">x5</span></code> 的内容保存到 <code class="docutils literal notranslate"><span class="pre">NUM``（地址0x1000）中。因此，全局变量</span> <span class="pre">``NUM</span></code> 现在的值是 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。</p>
<p>最后又发生一次线程上下文切换，线程A恢复运行，此时的 <code class="docutils literal notranslate"><span class="pre">x5=1</span></code>，现在线程A准备执行最后一条 <code class="docutils literal notranslate"><span class="pre">sd</span></code> 指令，将 <code class="docutils literal notranslate"><span class="pre">x5</span></code> 的内容保存到 <code class="docutils literal notranslate"><span class="pre">NUM</span></code> （地址0x1000）中，<code class="docutils literal notranslate"><span class="pre">NUM</span></code> 再次被设置为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。</p>
<p>简单总结，这两个线程执行的结果是：增加 <code class="docutils literal notranslate"><span class="pre">NUM</span></code> 的代码被执行两次，初始值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> ，但是结果为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。而我们一般理解这两个线程执行的“正确”结果应该是全局变量 <code class="docutils literal notranslate"><span class="pre">NUM</span></code> 等于  <code class="docutils literal notranslate"><span class="pre">2</span></code> 。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><strong>并发相关术语</strong></p>
<ul class="simple">
<li><p>共享资源（shared resource）：不同的线程/进程都能访问的变量或数据结构。</p></li>
<li><p>临界区（critical section）：访问共享资源的一段代码。</p></li>
<li><p>竞态条件（race condition）：多个线程/进程都进入临界区时，都试图更新共享的数据结构，导致产生了不期望的结果。</p></li>
<li><p>不确定性（indeterminate）： 多个线程/进程在执行过程中出现了竞态条件，导致执行结果取决于哪些线程在何时运行，即执行结果不确定，而开发者期望得到的是确定的结果。</p></li>
<li><p>互斥（mutual exclusion）：一种操作原语，能保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的执行结果。</p></li>
<li><p>原子性（atomic）：一系列操作要么全部完成，要么一个都没执行，不会看到中间状态。在数据库领域，具有原子性的一系列操作称为事务（transaction）。</p></li>
<li><p>同步（synchronization）：多个并发执行的进程/线程在一些关键点上需要互相等待，这种相互制约的等待称为进程/线程同步。</p></li>
<li><p>死锁（dead lock）：一个线程/进程集合里面的每个线程/进程都在等待只能由这个集合中的其他一个线程/进程（包括他自身）才能引发的事件，这种情况就是死锁。</p></li>
<li><p>饥饿（hungry）：指一个可运行的线程/进程尽管能继续执行，但由于操作系统的调度而被无限期地忽视，导致不能执行的情况。</p></li>
</ul>
</div>
<p>在后续的章节中，会大量使用上述术语，如果现在还不够理解，没关系，随着后续的一步一步的分析和实验，相信大家能够掌握上述术语的实际含义。</p>
</div>
</div>
<div class="section" id="id7">
<h2>实践体验<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>获取本章代码：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>git clone https://github.com/rcore-os/rCore-Tutorial-v3.git
<span class="gp">$ </span><span class="nb">cd</span> rCore-Tutorial-v3
<span class="gp">$ </span>git checkout ch8
</pre></div>
</div>
<p>在 qemu 模拟器上运行本章代码：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">cd</span> os
<span class="gp">$ </span>make run  <span class="c1"># 编译后，最终执行如下命令模拟rv64 virt计算机运行：</span>
<span class="go">......</span>
<span class="gp">$ </span>qemu-system-riscv64 <span class="se">\</span>
-machine virt <span class="se">\</span>
-nographic <span class="se">\</span>
-bios ../bootloader/rustsbi-qemu.bin <span class="se">\</span>
-device loader,file<span class="o">=</span>target/riscv64gc-unknown-none-elf/release/os.bin,addr<span class="o">=</span>0x80200000 <span class="se">\</span>
-drive <span class="nv">file</span><span class="o">=</span>../user/target/riscv64gc-unknown-none-elf/release/fs.img,if<span class="o">=</span>none,format<span class="o">=</span>raw,id<span class="o">=</span>x0 <span class="se">\</span>
     -device virtio-blk-device,drive<span class="o">=</span>x0,bus<span class="o">=</span>virtio-mmio-bus.0
</pre></div>
</div>
<p>在执行 <code class="docutils literal notranslate"><span class="pre">qemu-system-riscv64</span></code> 的参数中，<code class="docutils literal notranslate"><span class="pre">../user/target/riscv64gc-unknown-none-elf/release/fs.img</span></code> 是包含应用程序集合的文件系统镜像，这个镜像是放在虚拟硬盘块设备 <code class="docutils literal notranslate"><span class="pre">virtio-blk-device</span></code> （在下一章会进一步介绍这种存储设备）中的。</p>
<p>若要在 k210 平台上运行，首先需要将 microSD 通过读卡器插入 PC ，然后将打包应用 ELF 的文件系统镜像烧写到 microSD 中：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">cd</span> os
<span class="gp">$ </span>make sdcard
<span class="go">Are you sure write to /dev/sdb ? [y/N]</span>
<span class="go">y</span>
<span class="go">16+0 records in</span>
<span class="go">16+0 records out</span>
<span class="go">16777216 bytes (17 MB, 16 MiB) copied, 1.76044 s, 9.5 MB/s</span>
<span class="go">8192+0 records in</span>
<span class="go">8192+0 records out</span>
<span class="go">4194304 bytes (4.2 MB, 4.0 MiB) copied, 3.44472 s, 1.2 MB/s</span>
</pre></div>
</div>
<p>途中需要输入 <code class="docutils literal notranslate"><span class="pre">y</span></code> 确认将文件系统烧写到默认的 microSD 所在位置 <code class="docutils literal notranslate"><span class="pre">/dev/sdb</span></code> 中（注：这个位置在不同的Linux开发环境下可能是不同的）。这个位置可以在 <code class="docutils literal notranslate"><span class="pre">os/Makefile</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">SDCARD</span></code> 处进行修改，在烧写之前请确认它被正确配置为 microSD 的实际目录的位置，否则可能会造成数据损失。</p>
<p>烧写之后，将 microSD 插入到 Maix 系列开发板并连接到 PC，然后在开发板上运行本章代码：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">cd</span> os
<span class="gp">$ </span>make run <span class="nv">BOARD</span><span class="o">=</span>k210
</pre></div>
</div>
<p>内核初始化完成之后就会进入shell程序，我们可以体会一下线程的创建和执行过程。在这里我们运行一下本章的测例 <code class="docutils literal notranslate"><span class="pre">threads</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">threads</span>
<span class="n">aaa</span><span class="o">....</span><span class="n">bbb</span><span class="o">...</span><span class="n">ccc</span><span class="o">...</span>
<span class="n">thread</span><span class="c1">#1 exited with code 1</span>
    <span class="n">thread</span><span class="c1">#2 exited with code 2</span>
    <span class="n">thread</span><span class="c1">#3 exited with code 3</span>
    <span class="n">main</span> <span class="n">thread</span> <span class="n">exited</span><span class="o">.</span>
    <span class="n">Shell</span><span class="p">:</span> <span class="n">Process</span> <span class="mi">2</span> <span class="n">exited</span> <span class="k">with</span> <span class="n">code</span> <span class="mi">0</span>

<span class="o">&gt;&gt;</span>
</pre></div>
</div>
<p>它会有4个线程在执行，等前3个线程执行完毕后，主线程退出，导致整个进程退出。</p>
<p>此外，在本章的操作系统支持通过互斥来执行“哲学家就餐问题”这个应用程序：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">phil_din_mutex</span>
      <span class="n">time</span> <span class="n">cost</span> <span class="o">=</span> <span class="mi">7260</span>
     <span class="s1">&#39;-&#39;</span> <span class="o">-&gt;</span> <span class="n">THINKING</span><span class="p">;</span> <span class="s1">&#39;x&#39;</span> <span class="o">-&gt;</span> <span class="n">EATING</span><span class="p">;</span> <span class="s1">&#39; &#39;</span> <span class="o">-&gt;</span> <span class="n">WAITING</span>
     <span class="c1">#0: -------                 xxxxxxxx----------       xxxx-----  xxxxxx--xxx</span>
     <span class="c1">#1: ---xxxxxx--      xxxxxxx----------    x---xxxxxx</span>
     <span class="c1">#2: -----          xx---------xx----xxxxxx------------        xxxx</span>
     <span class="c1">#3: -----xxxxxxxxxx------xxxxx--------    xxxxxx--   xxxxxxxxx</span>
     <span class="c1">#4: ------         x------          xxxxxx--    xxxxx------   xx</span>
     <span class="c1">#0: -------                 xxxxxxxx----------       xxxx-----  xxxxxx--xxx</span>
     <span class="n">Shell</span><span class="p">:</span> <span class="n">Process</span> <span class="mi">2</span> <span class="n">exited</span> <span class="k">with</span> <span class="n">code</span> <span class="mi">0</span>
<span class="o">&gt;&gt;</span>
</pre></div>
</div>
<p>我们可以看到5个代表“哲学家”的线程通过操作系统的**信号量**互斥机制在进行“THINKING”、“EATING”、“WAITING”的日常生活。没有哲学家由于拿不到筷子而饥饿，也没有两个哲学家同时拿到一个筷子。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><strong>哲学家就餐问题</strong></p>
<p>计算机科学家Dijkstra提出并解决的哲学家就餐问题是经典的进程同步互斥问题。哲学家就餐问题描述如下：</p>
<p>有5个哲学家共用一张圆桌，分别坐在周围的5张椅子上，在圆桌上有5个碗和5只筷子，他们的生活方式是交替地进行思考和进餐。平时，每个哲学家进行思考，饥饿时便试图拿起其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐完毕，放下筷子继续思考。</p>
</div>
</div>
<div class="section" id="id8">
<h2>本章代码树<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span>     .
<span class="linenos">  2</span>     ├── bootloader
<span class="linenos">  3</span>     │   ├── rustsbi-k210.bin
<span class="linenos">  4</span>     │   └── rustsbi-qemu.bin
<span class="linenos">  5</span>     ├── dev-env-info.md
<span class="linenos">  6</span>     ├── Dockerfile
<span class="linenos">  7</span>     ├── easy-fs
<span class="linenos">  8</span>     │   ├── Cargo.lock
<span class="linenos">  9</span>     │   ├── Cargo.toml
<span class="linenos"> 10</span>     │   └── src
<span class="linenos"> 11</span>     │       ├── bitmap.rs
<span class="linenos"> 12</span>     │       ├── block_cache.rs
<span class="linenos"> 13</span>     │       ├── block_dev.rs
<span class="linenos"> 14</span>     │       ├── efs.rs
<span class="linenos"> 15</span>     │       ├── layout.rs
<span class="linenos"> 16</span>     │       ├── lib.rs
<span class="linenos"> 17</span>     │       └── vfs.rs
<span class="linenos"> 18</span>     ├── easy-fs-fuse
<span class="linenos"> 19</span>     │   ├── Cargo.lock
<span class="linenos"> 20</span>     │   ├── Cargo.toml
<span class="linenos"> 21</span>     │   └── src
<span class="linenos"> 22</span>     │       └── main.rs
<span class="linenos"> 23</span>     ├── LICENSE
<span class="linenos"> 24</span>     ├── Makefile
<span class="linenos"> 25</span>     ├── os
<span class="linenos"> 26</span>     │   ├── build.rs
<span class="linenos"> 27</span>     │   ├── Cargo.lock
<span class="linenos"> 28</span>     │   ├── Cargo.toml
<span class="linenos"> 29</span>     │   ├── last-qemu
<span class="linenos"> 30</span>     │   ├── Makefile
<span class="linenos"> 31</span>     │   └── src
<span class="linenos"> 32</span>     │       ├── config.rs
<span class="linenos"> 33</span>     │       ├── console.rs
<span class="linenos"> 34</span>     │       ├── drivers
<span class="linenos"> 35</span>     │       │   ├── block
<span class="linenos"> 36</span>     │       │   │   ├── mod.rs
<span class="linenos"> 37</span>     │       │   │   ├── sdcard.rs
<span class="linenos"> 38</span>     │       │   │   └── virtio_blk.rs
<span class="linenos"> 39</span>     │       │   └── mod.rs
<span class="linenos"> 40</span>     │       ├── entry.asm
<span class="linenos"> 41</span>     │       ├── fs
<span class="linenos"> 42</span>     │       │   ├── inode.rs
<span class="linenos"> 43</span>     │       │   ├── mod.rs
<span class="linenos"> 44</span>     │       │   ├── pipe.rs
<span class="linenos"> 45</span>     │       │   └── stdio.rs
<span class="linenos"> 46</span>     │       ├── lang_items.rs
<span class="linenos"> 47</span>     │       ├── link_app.S
<span class="linenos"> 48</span>     │       ├── linker-k210.ld
<span class="linenos"> 49</span>     │       ├── linker-qemu.ld
<span class="linenos"> 50</span>     │       ├── loader.rs
<span class="linenos"> 51</span>     │       ├── main.rs
<span class="linenos"> 52</span>     │       ├── mm
<span class="linenos"> 53</span>     │       │   ├── address.rs
<span class="linenos"> 54</span>     │       │   ├── frame_allocator.rs
<span class="linenos"> 55</span>     │       │   ├── heap_allocator.rs
<span class="linenos"> 56</span>     │       │   ├── memory_set.rs
<span class="linenos"> 57</span>     │       │   ├── mod.rs
<span class="linenos"> 58</span>     │       │   └── page_table.rs
<span class="linenos"> 59</span>     │       ├── sbi.rs
<span class="linenos"> 60</span>     │       ├── sync
<span class="linenos"> 61</span>     │       │   ├── mod.rs
<span class="linenos"> 62</span>     │       │   ├── mutex.rs
<span class="linenos"> 63</span>     │       │   ├── semaphore.rs
<span class="linenos"> 64</span>     │       │   └── up.rs
<span class="linenos"> 65</span>     │       ├── syscall
<span class="linenos"> 66</span>     │       │   ├── fs.rs
<span class="linenos"> 67</span>     │       │   ├── mod.rs
<span class="linenos"> 68</span>     │       │   ├── process.rs
<span class="linenos"> 69</span>     │       │   ├── sync.rs
<span class="linenos"> 70</span>     │       │   └── thread.rs
<span class="linenos"> 71</span>     │       ├── task
<span class="linenos"> 72</span>     │       │   ├── context.rs
<span class="linenos"> 73</span>     │       │   ├── id.rs
<span class="linenos"> 74</span>     │       │   ├── manager.rs
<span class="linenos"> 75</span>     │       │   ├── mod.rs
<span class="linenos"> 76</span>     │       │   ├── processor.rs
<span class="linenos"> 77</span>     │       │   ├── process.rs
<span class="linenos"> 78</span>     │       │   ├── switch.rs
<span class="linenos"> 79</span>     │       │   ├── switch.S
<span class="linenos"> 80</span>     │       │   └── task.rs
<span class="linenos"> 81</span>     │       ├── timer.rs
<span class="linenos"> 82</span>     │       └── trap
<span class="linenos"> 83</span>     │           ├── context.rs
<span class="linenos"> 84</span>     │           ├── mod.rs
<span class="linenos"> 85</span>     │           └── trap.S
<span class="linenos"> 86</span>     ├── pushall.sh
<span class="linenos"> 87</span>     ├── README.md
<span class="linenos"> 88</span>     ├── rust-toolchain
<span class="linenos"> 89</span>     └── user
<span class="linenos"> 90</span>         ├── Cargo.lock
<span class="linenos"> 91</span>         ├── Cargo.toml
<span class="linenos"> 92</span>         ├── Makefile
<span class="linenos"> 93</span>         └── src
<span class="linenos"> 94</span>             ├── bin
<span class="linenos"> 95</span>             │   ├── cat.rs
<span class="linenos"> 96</span>             │   ├── cmdline_args.rs
<span class="linenos"> 97</span>             │   ├── exit.rs
<span class="linenos"> 98</span>             │   ├── fantastic_text.rs
<span class="linenos"> 99</span>             │   ├── filetest_simple.rs
<span class="linenos">100</span>             │   ├── forktest2.rs
<span class="linenos">101</span>             │   ├── forktest.rs
<span class="linenos">102</span>             │   ├── forktest_simple.rs
<span class="linenos">103</span>             │   ├── forktree.rs
<span class="linenos">104</span>             │   ├── hello_world.rs
<span class="linenos">105</span>             │   ├── huge_write.rs
<span class="linenos">106</span>             │   ├── initproc.rs
<span class="linenos">107</span>             │   ├── matrix.rs
<span class="linenos">108</span>             │   ├── mpsc_sem.rs
<span class="linenos">109</span>             │   ├── phil_din_mutex.rs
<span class="linenos">110</span>             │   ├── pipe_large_test.rs
<span class="linenos">111</span>             │   ├── pipetest.rs
<span class="linenos">112</span>             │   ├── race_adder_atomic.rs
<span class="linenos">113</span>             │   ├── race_adder_loop.rs
<span class="linenos">114</span>             │   ├── race_adder_mutex_blocking.rs
<span class="linenos">115</span>             │   ├── race_adder_mutex_spin.rs
<span class="linenos">116</span>             │   ├── race_adder.rs
<span class="linenos">117</span>             │   ├── run_pipe_test.rs
<span class="linenos">118</span>             │   ├── sleep.rs
<span class="linenos">119</span>             │   ├── sleep_simple.rs
<span class="linenos">120</span>             │   ├── stack_overflow.rs
<span class="linenos">121</span>             │   ├── threads_arg.rs
<span class="linenos">122</span>             │   ├── threads.rs
<span class="linenos">123</span>             │   ├── user_shell.rs
<span class="linenos">124</span>             │   ├── usertests.rs
<span class="linenos">125</span>             │   └── yield.rs
<span class="linenos">126</span>             ├── console.rs
<span class="linenos">127</span>             ├── lang_items.rs
<span class="linenos">128</span>             ├── lib.rs
<span class="linenos">129</span>             ├── linker.ld
<span class="linenos">130</span>             └── syscall.rs
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>本章代码导读<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="1thread.html" class="btn btn-neutral float-right" title="用户态的线程管理" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="index.html" class="btn btn-neutral float-left" title="第八章：并发" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2020-2022, Yu Chen, Yifan Wu.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>